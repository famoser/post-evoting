/*
 * (c) Original Developers indicated in attribution.txt, 2021. All Rights Reserved.
 */
package ch.post.it.evoting.cryptolib.certificates.utils;

import static org.junit.jupiter.api.Assertions.assertArrayEquals;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.security.PublicKey;
import java.util.Date;

import ch.post.it.evoting.cryptolib.api.exceptions.GeneralCryptoLibException;
import ch.post.it.evoting.cryptolib.certificates.bean.RootCertificateData;
import ch.post.it.evoting.cryptolib.certificates.bean.X509CertificateType;
import ch.post.it.evoting.cryptolib.certificates.constants.X509CertificateConstants;
import ch.post.it.evoting.cryptolib.certificates.cryptoapi.CryptoAPIX509Certificate;

/**
 * Utility to check various types of certificate data generated by tests.
 */
public class X509CertificateTestDataChecker {

	/**
	 * Asserts that a certificate contains the correct content. If any content is incorrect, an error message specific to this content is output when
	 * the assertion fails.
	 *
	 * @param certificate     the certificate to be checked.
	 * @param certificateData the data used to generate the certificate.
	 * @param certificateType the type of the certificate.
	 * @param issuerPublicKey the public key of the certificate issuer.
	 * @throws GeneralCryptoLibException if there is an error when accessing data from the certificate.
	 */
	public static void assertCertificateContentCorrect(final CryptoAPIX509Certificate certificate, final RootCertificateData certificateData,
			final X509CertificateType certificateType, final PublicKey issuerPublicKey) throws GeneralCryptoLibException {

		assertTrue((certificate.getSerialNumber().bitLength() <= X509CertificateConstants.CERTIFICATE_SERIAL_NUMBER_MAX_BIT_LENGTH),
				"Serial number bit length " + certificate.getSerialNumber().bitLength() + " exceeds maximum "
						+ X509CertificateConstants.CERTIFICATE_SERIAL_NUMBER_MAX_BIT_LENGTH);

		assertTrue(certificate.checkValidity().isOk(), "Validity check failed.");

		final Date validDate = X509CertificateTestDataGenerator.getDateWithinValidityPeriod();
		assertTrue(certificate.checkValidity(validDate), "Validity check failed for date " + validDate);

		assertEquals(certificateData.getIssuerDn(), certificate.getIssuerDn(), "Unexpected issuer DN");

		assertEquals(certificateData.getSubjectDn(), certificate.getSubjectDn(), "Unexpected subject DN");

		assertEquals(X509CertificateTestDataGenerator.getEpochTimeString(certificateData.getValidityDates().getNotBefore()),
				X509CertificateTestDataGenerator.getEpochTimeString(certificate.getNotBefore()), "Unexpected starting date of validity");

		assertEquals(X509CertificateTestDataGenerator.getEpochTimeString(certificateData.getValidityDates().getNotAfter()),
				X509CertificateTestDataGenerator.getEpochTimeString(certificate.getNotAfter()), "Unexpected ending date of validity");

		assertArrayEquals(certificateData.getSubjectPublicKey().getEncoded(), certificate.getPublicKey().getEncoded(), "Unexpected public key ");

		assertTrue(certificate.isCertificateType(certificateType), "Certificate is not expected type: " + certificateType);

		assertTrue(certificate.verify(issuerPublicKey), "Certificate signature verification by issuer failed.");
	}
}
